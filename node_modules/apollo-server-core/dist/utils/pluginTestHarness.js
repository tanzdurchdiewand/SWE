"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const type_1 = require("graphql/type");
const schemaInstrumentation_1 = require("./schemaInstrumentation");
const apollo_server_caching_1 = require("apollo-server-caching");
const dispatcher_1 = require("./dispatcher");
const schemaHash_1 = require("./schemaHash");
async function pluginTestHarness({ pluginInstance, schema, logger, graphqlRequest, overallCachePolicy, executor, context = Object.create(null) }) {
    if (!schema) {
        schema = new type_1.GraphQLSchema({
            query: new type_1.GraphQLObjectType({
                name: 'RootQueryType',
                fields: {
                    hello: {
                        type: type_1.GraphQLString,
                        resolve() {
                            return 'hello world';
                        }
                    }
                }
            })
        });
    }
    const schemaHash = schemaHash_1.generateSchemaHash(schema);
    if (typeof pluginInstance.serverWillStart === 'function') {
        pluginInstance.serverWillStart({
            logger: logger || console,
            schema,
            schemaHash,
            engine: {},
        });
    }
    const requestContext = {
        logger: logger || console,
        schema,
        schemaHash: schemaHash_1.generateSchemaHash(schema),
        request: graphqlRequest,
        metrics: Object.create(null),
        source: graphqlRequest.query,
        cache: new apollo_server_caching_1.InMemoryLRUCache(),
        context,
    };
    requestContext.overallCachePolicy = overallCachePolicy;
    if (typeof pluginInstance.requestDidStart !== "function") {
        throw new Error("This test harness expects this to be defined.");
    }
    const listener = pluginInstance.requestDidStart(requestContext);
    const dispatcher = new dispatcher_1.Dispatcher(listener ? [listener] : []);
    const executionListeners = [];
    await dispatcher.invokeHookAsync('didResolveOperation', requestContext);
    dispatcher.invokeHookSync('executionDidStart', requestContext).forEach(executionListener => {
        if (typeof executionListener === 'function') {
            executionListeners.push({
                executionDidEnd: executionListener,
            });
        }
        else if (typeof executionListener === 'object') {
            executionListeners.push(executionListener);
        }
    });
    const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);
    const invokeWillResolveField = (...args) => executionDispatcher.invokeDidStartHook('willResolveField', ...args);
    Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
    schemaInstrumentation_1.enablePluginsForSchemaResolvers(schema);
    try {
        requestContext.response = await executor(requestContext);
        executionDispatcher.reverseInvokeHookSync("executionDidEnd");
    }
    catch (executionErr) {
        executionDispatcher.reverseInvokeHookSync("executionDidEnd", executionErr);
    }
    await dispatcher.invokeHookAsync("willSendResponse", requestContext);
    return requestContext;
}
exports.default = pluginTestHarness;
//# sourceMappingURL=pluginTestHarness.js.map