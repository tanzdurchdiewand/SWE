"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerBase = void 0;
const graphql_tools_1 = require("graphql-tools");
const loglevel_1 = __importDefault(require("loglevel"));
const graphql_1 = require("graphql");
const apollo_server_caching_1 = require("apollo-server-caching");
const index_1 = require("./index");
const playground_1 = require("./playground");
const schemaHash_1 = require("./utils/schemaHash");
const isDirectiveDefined_1 = require("./utils/isDirectiveDefined");
const createSHA_1 = __importDefault(require("./utils/createSHA"));
const requestPipeline_1 = require("./requestPipeline");
const apollo_server_env_1 = require("apollo-server-env");
const apollo_tools_1 = require("@apollographql/apollo-tools");
const apollo_tracing_1 = require("apollo-tracing");
const apollo_cache_control_1 = require("apollo-cache-control");
const agent_1 = require("apollo-engine-reporting/dist/agent");
const runHttpQuery_1 = require("./runHttpQuery");
const NoIntrospection = (context) => ({
    Field(node) {
        if (node.name.value === '__schema' || node.name.value === '__type') {
            context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', [node]));
        }
    },
});
function getEngineServiceId(engine, logger) {
    const engineApiKey = agent_1.getEngineApiKey({ engine, skipWarn: true, logger });
    if (engineApiKey) {
        return engineApiKey.split(':', 2)[1];
    }
    return;
}
function approximateObjectSize(obj) {
    return Buffer.byteLength(JSON.stringify(obj), 'utf8');
}
class ApolloServerBase {
    constructor(config) {
        var _a;
        this.graphqlPath = '/graphql';
        this.requestOptions = Object.create(null);
        this.plugins = [];
        this.toDispose = new Set();
        if (!config)
            throw new Error('ApolloServer requires options.');
        this.config = config;
        const { context, resolvers, schema, schemaDirectives, modules, typeDefs, parseOptions = {}, introspection, mocks, mockEntireSchema, engine, playground, plugins, gateway, cacheControl, experimental_approximateDocumentStoreMiB, ...requestOptions } = config;
        if (config.logger) {
            this.logger = config.logger;
        }
        else {
            const loglevelLogger = loglevel_1.default.getLogger("apollo-server");
            if (this.config.debug === true) {
                loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
            }
            else {
                loglevelLogger.setLevel(loglevel_1.default.levels.WARN);
            }
            this.logger = loglevelLogger;
        }
        if (gateway && (modules || schema || typeDefs || resolvers)) {
            throw new Error('Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`');
        }
        this.parseOptions = parseOptions;
        this.context = context;
        const isDev = process.env.NODE_ENV !== 'production';
        if ((typeof introspection === 'boolean' && !introspection) ||
            (introspection === undefined && !isDev)) {
            const noIntro = [NoIntrospection];
            requestOptions.validationRules = requestOptions.validationRules
                ? requestOptions.validationRules.concat(noIntro)
                : noIntro;
        }
        if (!requestOptions.cache) {
            requestOptions.cache = new apollo_server_caching_1.InMemoryLRUCache();
        }
        if (requestOptions.persistedQueries !== false) {
            const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || Object.create(null);
            requestOptions.persistedQueries = {
                cache: new apollo_server_caching_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
                ...apqOtherOptions,
            };
        }
        else {
            delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        if (engine && typeof engine === 'object') {
            if (!engine.logger) {
                engine.logger = this.logger;
            }
            if (engine.maskErrorDetails && engine.rewriteError) {
                throw new Error("Can't set both maskErrorDetails and rewriteError!");
            }
            else if (engine.rewriteError &&
                typeof engine.rewriteError !== 'function') {
                throw new Error('rewriteError must be a function');
            }
            else if (engine.maskErrorDetails) {
                engine.rewriteError = () => new graphql_1.GraphQLError('<masked>');
                delete engine.maskErrorDetails;
            }
        }
        this.engineServiceId = getEngineServiceId(engine, this.logger);
        const apiKey = agent_1.getEngineApiKey({ engine, skipWarn: true, logger: this.logger });
        if (apiKey) {
            this.engineApiKeyHash = createSHA_1.default('sha512')
                .update(apiKey)
                .digest('hex');
        }
        if (this.engineServiceId) {
            const { EngineReportingAgent } = require('apollo-engine-reporting');
            this.engineReportingAgent = new EngineReportingAgent(typeof engine === 'object' ? engine : Object.create({
                logger: this.logger,
            }));
        }
        if (gateway && ((_a = this.engineReportingAgent) === null || _a === void 0 ? void 0 : _a.schemaReport)) {
            throw new Error([
                "Schema reporting is not yet compatible with the gateway. If you're",
                "interested in using schema reporting with the gateway, please",
                "contact Apollo support.",
            ].join(' '));
        }
        this.playgroundOptions = playground_1.createPlaygroundOptions(playground);
        const _schema = this.initSchema();
        if (graphql_1.isSchema(_schema)) {
            const derivedData = this.generateSchemaDerivedData(_schema);
            this.schema = derivedData.schema;
            this.schemaDerivedData = Promise.resolve(derivedData);
        }
        else if (typeof _schema.then === 'function') {
            this.schemaDerivedData = _schema.then(schema => this.generateSchemaDerivedData(schema));
        }
        else {
            throw new Error("Unexpected error: Unable to resolve a valid GraphQLSchema.  Please file an issue with a reproduction of this error, if possible.");
        }
        this.ensurePluginInstantiation(plugins);
    }
    setGraphQLPath(path) {
        this.graphqlPath = path;
    }
    initSchema() {
        const { gateway, engine, schema, modules, typeDefs, resolvers, schemaDirectives, parseOptions, } = this.config;
        if (gateway) {
            this.toDispose.add(gateway.onSchemaChange(schema => (this.schemaDerivedData = Promise.resolve(this.generateSchemaDerivedData(schema)))));
            const graphVariant = agent_1.getEngineGraphVariant(engine, this.logger);
            const engineConfig = this.engineApiKeyHash && this.engineServiceId
                ? {
                    apiKeyHash: this.engineApiKeyHash,
                    graphId: this.engineServiceId,
                    ...(graphVariant && { graphVariant }),
                }
                : undefined;
            this.requestOptions.executor = gateway.executor;
            return gateway.load({ engine: engineConfig })
                .then(config => config.schema)
                .catch(err => {
                const message = "This data graph is missing a valid configuration.";
                this.logger.error(message + " " + (err && err.message || err));
                throw new Error(message + " More details may be available in the server logs.");
            });
        }
        let constructedSchema;
        if (schema) {
            constructedSchema = schema;
        }
        else if (modules) {
            const { schema, errors } = apollo_tools_1.buildServiceDefinition(modules);
            if (errors && errors.length > 0) {
                throw new Error(errors.map(error => error.message).join('\n\n'));
            }
            constructedSchema = schema;
        }
        else {
            if (!typeDefs) {
                throw Error('Apollo Server requires either an existing schema, modules or typeDefs');
            }
            const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
            if (!isDirectiveDefined_1.isDirectiveDefined(augmentedTypeDefs, 'cacheControl')) {
                augmentedTypeDefs.push(index_1.gql `
            enum CacheControlScope {
              PUBLIC
              PRIVATE
            }

            directive @cacheControl(
              maxAge: Int
              scope: CacheControlScope
            ) on FIELD_DEFINITION | OBJECT | INTERFACE
          `);
            }
            constructedSchema = graphql_tools_1.makeExecutableSchema({
                typeDefs: augmentedTypeDefs,
                schemaDirectives,
                resolvers,
                parseOptions,
            });
        }
        return constructedSchema;
    }
    generateSchemaDerivedData(schema) {
        const schemaHash = schemaHash_1.generateSchemaHash(schema);
        const { mocks, mockEntireSchema } = this.config;
        if (mocks || (typeof mockEntireSchema !== 'undefined' && mocks !== false)) {
            graphql_tools_1.addMockFunctionsToSchema({
                schema,
                mocks: typeof mocks === 'boolean' || typeof mocks === 'undefined'
                    ? {}
                    : mocks,
                preserveResolvers: typeof mockEntireSchema === 'undefined' ? false : !mockEntireSchema,
            });
        }
        const documentStore = this.initializeDocumentStore();
        return {
            schema,
            schemaHash,
            documentStore,
        };
    }
    async willStart() {
        var _a;
        try {
            var { schema, schemaHash } = await this.schemaDerivedData;
        }
        catch (err) {
            return;
        }
        const service = {
            logger: this.logger,
            schema: schema,
            schemaHash: schemaHash,
            engine: {
                serviceID: this.engineServiceId,
                apiKeyHash: this.engineApiKeyHash,
            },
        };
        if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {
            service.persistedQueries = {
                cache: this.requestOptions.persistedQueries.cache,
            };
        }
        await Promise.all(this.plugins.map(plugin => plugin.serverWillStart &&
            plugin.serverWillStart(service)));
    }
    async stop() {
        this.toDispose.forEach(dispose => dispose());
        if (this.engineReportingAgent) {
            this.engineReportingAgent.stop();
            await this.engineReportingAgent.sendAllReports();
        }
    }
    schemaIsFederated(schema) {
        const serviceType = schema.getType('_Service');
        if (!(serviceType && graphql_1.isObjectType(serviceType))) {
            return false;
        }
        const sdlField = serviceType.getFields().sdl;
        if (!sdlField) {
            return false;
        }
        const sdlFieldType = sdlField.type;
        if (!graphql_1.isScalarType(sdlFieldType)) {
            return false;
        }
        return sdlFieldType.name == 'String';
    }
    ensurePluginInstantiation(plugins = []) {
        const pluginsToInit = [];
        if (this.config.tracing) {
            pluginsToInit.push(apollo_tracing_1.plugin());
        }
        if (this.config.cacheControl !== false) {
            let cacheControlOptions = {};
            if (typeof this.config.cacheControl === 'boolean' &&
                this.config.cacheControl === true) {
                cacheControlOptions = {
                    stripFormattedExtensions: false,
                    calculateHttpHeaders: false,
                    defaultMaxAge: 0,
                };
            }
            else {
                cacheControlOptions = {
                    stripFormattedExtensions: true,
                    calculateHttpHeaders: true,
                    defaultMaxAge: 0,
                    ...this.config.cacheControl,
                };
            }
            pluginsToInit.push(apollo_cache_control_1.plugin(cacheControlOptions));
        }
        const federatedSchema = this.schema && this.schemaIsFederated(this.schema);
        const { engine } = this.config;
        if (this.engineReportingAgent) {
            if (federatedSchema) {
                this.logger.warn("It looks like you're running a federated schema and you've configured your service " +
                    'to report metrics to Apollo Graph Manager. You should only configure your Apollo gateway ' +
                    'to report metrics to Apollo Graph Manager.');
                if (this.engineReportingAgent.schemaReport) {
                    throw Error([
                        "Schema reporting is not yet compatible with federated services.",
                        "If you're interested in using schema reporting with federated",
                        "services, please contact Apollo support.",
                    ].join(' '));
                }
            }
            pluginsToInit.push(this.engineReportingAgent.newPlugin());
        }
        else if (engine !== false && federatedSchema) {
            const { federatedPlugin } = require('apollo-engine-reporting');
            const rewriteError = engine && typeof engine === 'object' ? engine.rewriteError : undefined;
            pluginsToInit.push(federatedPlugin({ rewriteError }));
        }
        pluginsToInit.push(...plugins);
        this.plugins = pluginsToInit.map(plugin => {
            if (typeof plugin === 'function') {
                return plugin();
            }
            return plugin;
        });
    }
    initializeDocumentStore() {
        return new apollo_server_caching_1.InMemoryLRUCache({
            maxSize: Math.pow(2, 20) *
                (this.experimental_approximateDocumentStoreMiB || 30),
            sizeCalculator: approximateObjectSize,
        });
    }
    async graphQLServerOptions(integrationContextArgument) {
        const { schema, schemaHash, documentStore, } = await this.schemaDerivedData;
        let context = this.context ? this.context : {};
        try {
            context =
                typeof this.context === 'function'
                    ? await this.context(integrationContextArgument || {})
                    : context;
        }
        catch (error) {
            context = () => {
                throw error;
            };
        }
        return {
            schema,
            schemaHash,
            logger: this.logger,
            plugins: this.plugins,
            documentStore,
            context,
            persistedQueries: this.requestOptions
                .persistedQueries,
            fieldResolver: this.requestOptions.fieldResolver,
            parseOptions: this.parseOptions,
            ...this.requestOptions,
        };
    }
    async executeOperation(request) {
        const options = await this.graphQLServerOptions();
        if (typeof options.context === 'function') {
            options.context = options.context();
        }
        else if (typeof options.context === 'object') {
            options.context = runHttpQuery_1.cloneObject(options.context);
        }
        const requestCtx = {
            logger: this.logger,
            schema: options.schema,
            schemaHash: options.schemaHash,
            request,
            context: options.context || Object.create(null),
            cache: options.cache,
            metrics: {},
            response: {
                http: {
                    headers: new apollo_server_env_1.Headers(),
                },
            },
        };
        return requestPipeline_1.processGraphQLRequest(options, requestCtx);
    }
}
exports.ApolloServerBase = ApolloServerBase;
//# sourceMappingURL=ApolloServer.js.map